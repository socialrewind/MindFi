using System;
using Shell32;
using System.IO;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Threading;
using MBBetaAPI.AgentAPI;
 
namespace MBBetaAPI
{
    public class SRZipBackup
    {
        public static volatile bool InBackup = false;
        public static string ErrorMessage;

        /// <summary>
        /// Creates a Zip from a full backup folder
        /// </summary>
        /// <param name="SourcePath">Folder to compress</param>
        /// <param name="Destination">Destination zip file</param>
        public static void CreateZipBackup(string SourcePath, string Destination)
        {
            DBLayer.LockDatabaseForCopy();
            InBackup = true;
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new System.ComponentModel.DoWorkEventHandler(bw_ZipFolder);
            AsyncZipArgs temp = new AsyncZipArgs(SourcePath, Destination);
            bw.RunWorkerAsync(temp);
        }

        private static void bw_ZipFolder(object sender, DoWorkEventArgs e)
        {
            BackgroundWorker worker = sender as BackgroundWorker;
            AsyncZipArgs temp = (AsyncZipArgs)e.Argument;

            ShellCompressFolder(temp.Source, temp.Destination);
            // only when finished...
            InBackup = false;
            DBLayer.UnlockDatabaseForCopy();
        }

        /// <summary>
        /// Creates a folder from a zip backup
        /// </summary>
        /// <param name="SourcePath">Zip to uncompress</param>
        /// <param name="Destination">Destination folder name</param>
        public static void UnzipBackup(string SourcePath, string Destination)
        {
            InBackup = true;
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += new System.ComponentModel.DoWorkEventHandler(bw_UnzipFolder);
            AsyncZipArgs temp = new AsyncZipArgs(SourcePath, Destination);
            bw.RunWorkerAsync(temp);
        }

        private static void bw_UnzipFolder(object sender, DoWorkEventArgs e)
        {
            BackgroundWorker worker = sender as BackgroundWorker;
            AsyncZipArgs temp = (AsyncZipArgs)e.Argument;
            ShellUnCompressFolder(temp.Source, temp.Destination);
            InBackup = false;
        }

        // sample from http://social.msdn.microsoft.com/Forums/en/netfxbcl/thread/b409dc2b-397c-44cd-b3a6-377066c591a9
        // ese also http://www.codeproject.com/Articles/34165/How-to-Utilise-the-Shell32-Library-in-NET-as-a-COM
        public static void ShellCompressFolder(string Source, string Dest)
        {
            Shell Shl = new Shell();
            // standard zip header
            File.WriteAllBytes(Dest, new byte[] { 80, 75, 5, 6, 0, 0, 0, 0, 0, 0, 0, 
                                                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
            ErrorMessage = "";
            int errorCode1, errorCode2;

            try { 
                // http://msdn.microsoft.com/en-us/library/windows/desktop/bb787866(v=vs.85).aspx
                //Shl.NameSpace(Dest).CopyHere(Source, 0);

                errorCode1 = Marshal.GetLastWin32Error();

                Folder temp = Shl.NameSpace(Dest);
                temp.CopyHere(Source, 512); // flag to create
                bool Cancelled = false; 
                // make sure file is created
                FolderItems x;
                // byte[] getdata;
                
                // allow rampup time
                Thread.Sleep(4000);
                do
                {
                    Thread.Sleep(1000);
                    x = temp.Items();
                    // HACK: Access the file to know if zip is cancelled...
                    try
                    {
                        //getdata = File.ReadAllBytes(Dest);
                        FileStream tempStream = File.OpenWrite(Dest);
                        Cancelled = true;
                        tempStream.Close();
                    }
                    catch ( Exception )
                    {
                        // TODO: create constant for error codes
                        // TODO: check exception is the expected exception, if not, "cancel"
                    }
                    errorCode2 = Marshal.GetLastWin32Error();
                } while (x.Count == 0 
                    && (errorCode2 == errorCode1 
                    || errorCode2 == 32) // generated by the planned exception
                    && !Cancelled);
                if (!File.Exists(Dest))
                {
                    Cancelled = true;
                } else if (x.Count != 0)
                {
                    Cancelled = false;
                }
                if (Cancelled)
                {
                    // TODO: Localize
                    ErrorMessage = "Zip Backup was cancelled";
                    File.Delete(Dest);
                }
                // TODO: create constant for error codes
                if (errorCode1 != errorCode2 && errorCode2 != 183)
                {
                    // TODO: Localize
                    ErrorMessage = "Error creating zip " + errorCode2;
                    System.Diagnostics.Debug.WriteLine(ErrorMessage);
                }
            }
            catch ( Exception ex )
            {
                ErrorMessage = "Exception creating zip " + ex.ToString();
                System.Diagnostics.Debug.WriteLine(ErrorMessage);
            } 
        }

        public static void ShellUnCompressFolder(string Source, string Dest)
        {
            Shell SH = new Shell();
            Folder SF = SH.NameSpace(Source); // zip
            Folder DF = SH.NameSpace(Dest); // new folder
            FolderItems Sitems = SF.Items();
            // big advantage: this is synchronous
            foreach ( FolderItem x in Sitems )
            {
                DF.CopyHere(x);
            }
        }
    }

    public class AsyncZipArgs
    {
        public string Source;
        public string Destination;

        public AsyncZipArgs(string source, string dest)
        {            
            Source = source;
            Destination = dest;
        }
    }
}
